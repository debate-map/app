var path = require('path');
var extend = require('util')._extend;

function CircularDependencyPlugin(options) {
  this.options = extend({
    exclude: new RegExp('$^'),
    failOnError: false
  }, options);
}

function isCyclic(initialModule, currentModule, seenModules) {
  seenModules[currentModule.id] = {};

  if (!currentModule.resource || !initialModule.resource) {
    return false;
  }

  for (var i in currentModule.dependencies) {
    var dep = currentModule.dependencies[i].module;

    if (!dep) {
      continue;
    }

    if (dep.id in seenModules) {
      if (dep.id === initialModule.id) {
        // Initial module has circ dep
        return [path.relative(process.cwd(), currentModule.resource), path.relative(process.cwd(), dep.resource)];
      }
      // Found a cycle, but not for this module
      continue;
    }
    var cyclePath = isCyclic(initialModule, dep, seenModules);
    if (cyclePath) {
      cyclePath.unshift(path.relative(process.cwd(), currentModule.resource));
      return cyclePath;
    }
  }
  return null;
}

CircularDependencyPlugin.prototype.apply = function(compiler) {
  var plugin = this;

  compiler.plugin('done', function(stats){
    var modules = stats.compilation.modules;

	 // custom
	 let cyclePaths = [];

    modules.forEach(function(module){
      if (module.resource === undefined || plugin.options.exclude.test(module.resource)) { return; }
      var cyclePath = isCyclic(module, module, {});
      if (cyclePath) {

			// custom removed
        /*var relativePathToModule = path.relative(process.cwd(), module.resource);
        var error = new Error('Circular dependency detected:\r\n'.concat(cyclePath.join(' -> ')));
        if (plugin.options.failOnError) {
          stats.compilation.errors.push(error);
        } else {
          stats.compilation.warnings.push(error);
        }*/

			// custom
			cyclePaths.push(cyclePath);

      }
    });

	// custom
	let moduleTotals = {};
	for (let path of cyclePaths) {
		for (let pathNode of path) {
			moduleTotals[pathNode] = (moduleTotals[pathNode]|0) + 1;
		}
	}
	console.log('\n\nCircular dependency counts:\n\n');
	let moduleNames_sortedByTotals = SortArrayDescending(Object.keys(moduleTotals), name=>moduleTotals[name]);
	for (let moduleName of moduleNames_sortedByTotals) {
		//stats.compilation.warnings.push(new Error('\n\nCircular dependency counts:\n\n'.concat(cyclePath.join(' -> '))));
		console.log(moduleName + ": " + moduleTotals[moduleName]);
	}
	console.log('\n\n');

  });
}

// custom
function SortArray(array, valFunc = (item, index)=>item) {
    return StableSort(array, (a, b, aIndex, bIndex)=>Compare(valFunc(a, aIndex), valFunc(b, bIndex)));
};
function SortArrayDescending(array, valFunc = (item, index)=>item) {
	return SortArray(array, (item, index)=>-valFunc(item, index));
};
function StableSort(array, compareFunc) { // needed for Chrome
	var array2 = array.map((item, index)=>({index, item}));
	array2.sort((a, b)=> {
		var r = compareFunc(a.item, b.item, a.index, b.index);
		return r != 0 ? r : Compare(a.index, b.index);
	});
	return array2.map(pack=>pack.item);
}
function Compare(a, b, caseSensitive = true) {
	if (!caseSensitive && typeof a == "string" && typeof b == "string") {
		a = a.toLowerCase();
		b = b.toLowerCase();
	}
	return a < b ? -1 : (a > b ? 1 : 0);
}

module.exports = CircularDependencyPlugin;