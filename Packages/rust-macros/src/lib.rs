use std::{env};
use std::time::Instant;

use cached_expand::cached_expand_impl;
use proc_macro2::TokenStream;
use wrap_agql_schema_build::{wrap_agql_schema_build_impl, wrap_agql_schema_type_impl};
use wrap_async_graphql::wrap_async_graphql_impl;
use wrap_serde_macros::wrap_serde_macros_impl;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

extern crate proc_macro;
extern crate syn;

mod utils;
mod cached_expand;
mod wrap_async_graphql;
mod wrap_agql_schema_build;
mod wrap_serde_macros;

#[proc_macro]
/// Use this as a way of "commenting" a macro temporarily, without needing to find the end-bracket.
pub fn unchanged(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    input
}

// higher level (ie. combining multiple macros into one)
// ==========

#[proc_macro]
pub fn wrap_slow_macros(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let proceed = {
        let mut temp = false;
        if let Ok(val) = env::var("FOR_RUST_ANALYZER") {
            if val == "1" {
                //println!("Macro wrap_slow_macros: Modifying tokens, since FOR_RUST_ANALYZER is true.");
                temp = true;
            }
        }
        temp
    };
    if !proceed {
        return input;
    }
    
    let output = TokenStream::from(input);
    let t1 = Instant::now();
    let output = wrap_async_graphql_impl(output, true);
    let t2 = Instant::now();
    let output = wrap_serde_macros_impl(output, true);
    let t3 = Instant::now();

    // typical result, in dm-repo: [11ms, 6ms]
    println!("Macro wrap_slow_macros: Timings = [{}ms, {}ms]", (t2 - t1).as_millis(), (t3 - t2).as_millis());

    proc_macro::TokenStream::from(output)
}

// base macros
// ==========

#[proc_macro]
pub fn wrap_agql_schema_type(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let output = wrap_agql_schema_type_impl(TokenStream::from(input), false);
    proc_macro::TokenStream::from(output)
}

#[proc_macro]
pub fn wrap_agql_schema_build(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let output = wrap_agql_schema_build_impl(TokenStream::from(input), false);
    proc_macro::TokenStream::from(output)
}

#[proc_macro]
pub fn cached_expand(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let output = cached_expand_impl(TokenStream::from(input));
    proc_macro::TokenStream::from(output)
}

#[proc_macro]
pub fn wrap_async_graphql(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let output = wrap_async_graphql_impl(TokenStream::from(input), false);
    proc_macro::TokenStream::from(output)
}

#[proc_macro]
pub fn wrap_serde_macros(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let output = wrap_serde_macros_impl(TokenStream::from(input), false);
    proc_macro::TokenStream::from(output)
}

// derive macros
// todo: fix that these fail for structs that already have their own "'X" lifetimes specified
// ==========

#[proc_macro_derive(Serialize_Stub)]
pub fn serialize_stub(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);
    let struct_name = &ast.ident;
    
    proc_macro::TokenStream::from(quote! {
        #[doc(hidden)]
        #[allow(non_upper_case_globals,unused_attributes,unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates,clippy::useless_attribute)]
            extern crate serde as _serde;

            #[automatically_derived]
            impl _serde::Serialize for #struct_name {
                fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error> where __S: _serde::Serializer {
                    Err(_serde::ser::Error::custom("This is a placeholder generated by the Serialize_Stub macro, for quick resolution during cargo-check. You should not be seeing this at runtime."))
                }
            }
        };
    })
}


#[proc_macro_derive(Deserialize_Stub)]
pub fn deserialize_stub(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);
    let struct_name = &ast.ident;
    
    proc_macro::TokenStream::from(quote! {
        #[doc(hidden)]
        #[allow(non_upper_case_globals,unused_attributes,unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates,clippy::useless_attribute)]
            extern crate serde as _serde;

            #[automatically_derived]
            impl <'de> _serde::Deserialize<'de> for #struct_name {
                fn deserialize<__D>(__deserializer:__D) -> _serde::__private::Result<Self, __D::Error> where __D: _serde::Deserializer<'de> {
                    Err(_serde::de::Error::custom("This is a placeholder generated by the Deserialize_Stub macro, for quick resolution during cargo-check. You should not be seeing this at runtime."))
                }
            }
        };
    })
}