use std::env;
use std::time::Instant;

use cached_expand::cached_expand_impl;
use proc_macro2::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};
use wrap_agql_schema_build::{wrap_agql_schema_build_impl, wrap_agql_schema_type_impl};
use wrap_async_graphql::wrap_async_graphql_impl;
use wrap_serde_macros::wrap_serde_macros_impl;

extern crate proc_macro;
extern crate syn;

mod cached_expand;
mod utils;
mod wrap_agql_schema_build;
mod wrap_async_graphql;
mod wrap_serde_macros;

#[proc_macro]
/// Use this as a way of "commenting" a macro temporarily, without needing to find the end-bracket.
pub fn unchanged(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
	input
}

#[proc_macro_attribute]
pub fn unchanged_attr(_args: proc_macro::TokenStream, input: proc_macro::TokenStream) -> proc_macro::TokenStream {
	input
}

// higher level (ie. combining multiple macros into one)
// ==========

#[proc_macro]
pub fn wrap_slow_macros(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
	let proceed = {
		let mut temp = false;
		if let Ok(val) = env::var("FOR_RUST_ANALYZER") {
			if val == "1" {
				//println!("Macro wrap_slow_macros: Modifying tokens, since FOR_RUST_ANALYZER is true.");
				temp = true;
			}
		}
		temp
	};
	if !proceed {
		return input;
	}

	let output = TokenStream::from(input);
	let t1 = Instant::now();
	let output = wrap_async_graphql_impl(output, true);
	let t2 = Instant::now();
	let output = wrap_serde_macros_impl(output, true);
	let t3 = Instant::now();

	// typical result, in dm-repo: [11ms, 6ms]
	println!("Macro wrap_slow_macros: Timings = [{}ms, {}ms]", (t2 - t1).as_millis(), (t3 - t2).as_millis());

	proc_macro::TokenStream::from(output)
}

// base macros
// ==========

#[proc_macro]
pub fn wrap_agql_schema_type(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
	let output = wrap_agql_schema_type_impl(TokenStream::from(input), false);
	proc_macro::TokenStream::from(output)
}

#[proc_macro]
pub fn wrap_agql_schema_build(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
	let output = wrap_agql_schema_build_impl(TokenStream::from(input), false);
	proc_macro::TokenStream::from(output)
}

#[proc_macro]
pub fn cached_expand(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
	let output = cached_expand_impl(TokenStream::from(input));
	proc_macro::TokenStream::from(output)
}

#[proc_macro]
pub fn wrap_async_graphql(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
	let output = wrap_async_graphql_impl(TokenStream::from(input), false);
	proc_macro::TokenStream::from(output)
}

#[proc_macro]
pub fn wrap_serde_macros(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
	let output = wrap_serde_macros_impl(TokenStream::from(input), false);
	proc_macro::TokenStream::from(output)
}

// derive macros
// todo: fix that these fail for structs that already have their own "'X" lifetimes specified
// ==========

#[proc_macro_derive(Serialize_Stub)]
pub fn serialize_stub(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
	let ast = parse_macro_input!(input as DeriveInput);
	let struct_name = &ast.ident;

	/*let orig_span = ast.ident.span();
	proc_macro::TokenStream::from(quote_spanned! {orig_span=>
		#[automatically_derived]
		impl serde::Serialize for #struct_name {
			fn serialize<__S>(&self, __serializer: __S) -> serde::__private::Result<__S::Ok, __S::Error> where __S: serde::Serializer {
				Err(serde::ser::Error::custom("This is a placeholder generated by the Serialize_Stub macro, for quick resolution during cargo-check. You should not be seeing this at runtime."))
			}
		}
	})*/
	proc_macro::TokenStream::from(quote! {
		#[doc(hidden)]
		#[allow(non_upper_case_globals,unused_attributes,unused_qualifications)]
		const _: () = {
			#[allow(unused_extern_crates,clippy::useless_attribute)]
			extern crate serde as _serde;
			//extern crate rust_shared::serde as _serde;
			//use rust_shared::serde as _serde;

			#[automatically_derived]
			impl _serde::Serialize for #struct_name {
				fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error> where __S: _serde::Serializer {
					Err(_serde::ser::Error::custom("This is a placeholder generated by the Serialize_Stub macro, for quick resolution during cargo-check. You should not be seeing this at runtime."))
				}
			}
		};
	})
}

#[proc_macro_derive(Deserialize_Stub)]
pub fn deserialize_stub(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
	let ast = parse_macro_input!(input as DeriveInput);
	let struct_name = &ast.ident;

	/*let orig_span = ast.ident.span();
	proc_macro::TokenStream::from(quote_spanned! {orig_span=>
		#[automatically_derived]
		impl <'de> serde::Deserialize<'de> for #struct_name {
			fn deserialize<__D>(__deserializer:__D) -> serde::__private::Result<Self, __D::Error> where __D: serde::Deserializer<'de> {
				Err(serde::de::Error::custom("This is a placeholder generated by the Deserialize_Stub macro, for quick resolution during cargo-check. You should not be seeing this at runtime."))
			}
		}
	})*/
	proc_macro::TokenStream::from(quote! {
		#[doc(hidden)]
		#[allow(non_upper_case_globals,unused_attributes,unused_qualifications)]
		const _: () = {
			#[allow(unused_extern_crates,clippy::useless_attribute)]
			extern crate serde as _serde;
			//extern crate rust_shared::serde as _serde;
			//use rust_shared::serde as _serde;

			#[automatically_derived]
			impl <'de> _serde::Deserialize<'de> for #struct_name {
				fn deserialize<__D>(__deserializer:__D) -> _serde::__private::Result<Self, __D::Error> where __D: _serde::Deserializer<'de> {
					Err(_serde::de::Error::custom("This is a placeholder generated by the Deserialize_Stub macro, for quick resolution during cargo-check. You should not be seeing this at runtime."))
				}
			}
		};
	})
}
