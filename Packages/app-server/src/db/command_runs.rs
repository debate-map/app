use futures_util::{stream, Stream, TryFutureExt};
use rust_shared::async_graphql::{Context, Object, OutputType, Schema, SimpleObject, Subscription, ID};
use rust_shared::rust_macros::{wrap_serde_macros, wrap_slow_macros, Deserialize_Stub, Serialize_Stub};
use rust_shared::serde::{Deserialize, Serialize};
use rust_shared::tokio_postgres::{Client, Row};
use rust_shared::{async_graphql, serde, serde_json, GQLError, SubError};

use crate::gql_set_impl;
use crate::utils::db::generic_handlers::queries::{handle_generic_gql_collection_query, handle_generic_gql_doc_query};
use crate::utils::db::pg_row_to_json::postgres_row_to_struct;
use crate::utils::db::{
	filter::{FilterInput, QueryFilter},
	generic_handlers::subscriptions::{handle_generic_gql_collection_subscription, handle_generic_gql_doc_subscription, GQLSet},
};

use super::_shared::access_policy_target::AccessPolicyTarget;

// for testing wrap_serde_macros! on a single struct
/*wrap_serde_macros!{
#[derive(Serialize, Deserialize)]
pub struct Test1 {}
}*/

#[derive(Serialize_Stub, Deserialize_Stub)]
pub struct Test1 {}

/*#[derive(Serialize, Deserialize)]
pub struct Test2 {}*/
/*impl serde::Serialize for Test2 {
	fn serialize<__S>(&self, __serializer: __S) -> serde::__private::Result<__S::Ok, __S::Error> where __S: serde::Serializer {
		Err(serde::ser::Error::custom("This is a placeholder generated by the Serialize_Stub macro, for quick resolution during cargo-check. You should not be seeing this."))
	}
}
impl <'de> serde::Deserialize<'de> for Test2 {
	fn deserialize<__D>(__deserializer:__D) -> serde::__private::Result<Self, __D::Error> where __D: serde::Deserializer<'de> {
		Err(serde::de::Error::custom("This is a placeholder generated by the Deserialize_Stub macro, for quick resolution during cargo-check. You should not be seeing this."))
	}
}*/

wrap_slow_macros! {

/*cached_expand!{
const ce_args: &str = r##"
id = "command_runs"
excludeLinesWith = "#[graphql(name"
"##;*/

/*#[derive(SimpleObject, Deserialize)]
pub struct RLSTargets {
	pub nodes: Vec<String>,
}*/

#[derive(SimpleObject, Clone, Serialize, Deserialize)]
pub struct CommandRun {
	pub id: ID,
	pub actor: String,
	pub runTime: i64,
	#[graphql(name = "public_base")]
	pub public_base: bool,
	pub commandName: String,
	pub commandInput: serde_json::Value,
	pub commandResult: serde_json::Value,

	#[graphql(name = "c_involvedNodes")]
	pub c_involvedNodes: Vec<String>,
	#[graphql(name = "c_accessPolicyTargets")]
	pub c_accessPolicyTargets: Vec<AccessPolicyTarget>,
}
impl From<Row> for CommandRun {
	fn from(row: Row) -> Self { postgres_row_to_struct(row).unwrap() }
}

gql_set_impl!(CommandRun);

#[derive(Default)] pub struct QueryShard_CommandRun;
#[Object] impl QueryShard_CommandRun {
	async fn commandRuns(&self, ctx: &Context<'_>, filter: Option<FilterInput>) -> Result<Vec<CommandRun>, GQLError> {
		handle_generic_gql_collection_query(ctx, "commandRuns", filter).await
	}
	async fn commandRun(&self, ctx: &Context<'_>, id: String) -> Result<Option<CommandRun>, GQLError> {
		handle_generic_gql_doc_query(ctx, "commandRuns", id).await
	}
}

#[derive(Default)] pub struct SubscriptionShard_CommandRun;
#[Subscription] impl SubscriptionShard_CommandRun {
	async fn commandRuns<'a>(&self, ctx: &'a Context<'_>, filter: Option<FilterInput>) -> impl Stream<Item = Result<GQLSet_CommandRun, SubError>> + 'a {
		handle_generic_gql_collection_subscription::<CommandRun, GQLSet_CommandRun>(ctx, "commandRuns", filter, None).await
	}
	async fn commandRun<'a>(&self, ctx: &'a Context<'_>, id: String) -> impl Stream<Item = Result<Option<CommandRun>, SubError>> + 'a {
		handle_generic_gql_doc_subscription::<CommandRun>(ctx, "commandRuns", id).await
	}
}

}
